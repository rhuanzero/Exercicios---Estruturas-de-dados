3) Implemente agora um construtor que faça uma operação análoga para a classe
HeapBinariaMaxima. Esse construtor deve seguir o seguinte protótipo:
public HeapBinariaMaxima(HeapBinariaMinima heapMinima);

Métodos adicionados em HeapBinariaMinima:

public int getTam() {
	return tam;
}
public int get(int i) {
	return vetor[i+1];
}
public int getN() {
	return n;
}

Método adicionado em HeapBinariaMaxima:
public HeapBinariaMaxima(HeapBinariaMinima heapMinima) {
		this.n = heapMinima.getN();		
		this.tam = heapMinima.getTam();
		this.vetor = new int[tam + 1];
	
		
		for(int i = 0;i<n;i++) 
			vetor[i+1] = heapMinima.get(i);
	
		int ultno = n/2;
		
		for( int i = ultno; i > 0; i-- ) {
			int x = vetor[i];
			
			while(2*i <= n) {// Enquanto o filho esquerdo existir
				int filhoesq = 2*i, filhodir = 2*i+1, maiorfilho;
				
				maiorfilho = filhoesq;
				
				if(filhodir<=n) { // Verifica se o filho existe
					if(vetor[maiorfilho] < vetor[filhodir]) { // Verifica se o filho esquerdo é o maiorfilho
						maiorfilho = filhodir;
					}
				}
				if(vetor[maiorfilho] > x) {
					vetor[i] = vetor[maiorfilho];
				}
				else
					break;
				
				i = maiorfilho;
			}
		
			vetor[i] = x;
		
		}
		
	}
	
Complexidade do construtor :
O(n) - sendo n o numero de elementos na heap



	